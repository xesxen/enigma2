# takes a header file, outputs action ids

import tokenize
import sys


def filter(g):
	while 1:
		t = g.__next__()
		if t[1] == "/*":
			while g.__next__()[1] != "*/":
				pass
			continue
		if t[1] == "//":
			while g.__next__()[1] != "\n":
				pass
			continue

		if t[1] != "\n":
#			print t
			yield t[1]


def do_file(f, mode):
	tokens = filter(tokenize.generate_tokens(open(f, 'r').readline))

	sys.stderr.write("parsing %s\n" % f)

	state = 0

	classstate = 0

	firsthit = 1

	while 1:
		try:
			t = tokens.__next__()
		except:
			break

		if t == "class":
			classname = tokens.__next__()
			classstate = state

		if t == "{":
			state += 1

		if t == "}":
			state -= 1

		if t == "enum" and state == classstate + 1:
			actionname = tokens.__next__()

			if actionname == "{":
				while tokens.__next__() != "}":
					pass
				continue

			if actionname[-7:] == "Actions":
				if tokens.__next__() != "{":
					try:
						print(classname)
					except:
						pass

					try:
						print(actionname)
					except:
						pass

					raise Exception("action enum must be simple.")

				counter = 0

				while 1:

					t = tokens.__next__()

					if t == "=":
						tokens.__next__()
						t = tokens.__next__()

					if t == "}":
						break

					if counter:
						if t != ",":
							raise Exception("no comma")
						t = tokens.__next__()

					if firsthit:

						if mode == "include":
							# hack hack hack!!
							print("#include <lib/" + '/'.join(f.split('/')[-2:]) + ">")
						else:
							print("\t// " + f)

						firsthit = 0

					if mode == "parse":
						print("{\"" + actionname + "\", \"" + t + "\", " + "::".join((classname, t)) + "},")

					counter += 1


mode = sys.argv[1]

if mode == "parse":
	print("""
	/* generated by parseactions.py - do not modify! */
struct eActionList
{
	const char *m_context, *m_action;
	int m_id;
} actions[]={""")

for x in sys.argv[2:]:
	do_file(x, mode)

if mode == "parse":
	print("};")
